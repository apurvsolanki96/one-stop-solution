// File: one-stop-solution/docs/script.js (REPLACE)
// Frontend glue: theme toggle, online/offline parse fallback, memory (localStorage),
// admin panel, and Save-to-Memory dialog.

(function () {
  'use strict';

  // --- Utilities ---
  const $ = (sel) => document.querySelector(sel);
  const byId = (id) => document.getElementById(id);
  const MEM_KEY = 'oss_learned_notams_v1';
  const THEME_KEY = 'oss_theme_v1';
  function now() { return new Date().toISOString(); }
  function canonicalInput(s) { return (s || '').trim().replace(/\s+/g, ' ').toUpperCase(); }

  // --- Memory helpers (localStorage) ---
  function loadMemory() { try { return JSON.parse(localStorage.getItem(MEM_KEY) || '[]'); } catch (e) { return []; } }
  function saveMemory(arr) { localStorage.setItem(MEM_KEY, JSON.stringify(arr || [])); updateMemoryBadge(); }
  function updateMemoryBadge() { const el = byId('memoryBadge'); if (!el) return; const n = loadMemory().length; el.textContent = `Memory: ${n} item${n === 1 ? '' : 's'}`; }
  function addMemoryEntry(inputText, outputArray) {
    const mem = loadMemory();
    const key = canonicalInput(inputText);
    const entry = { id: Math.random().toString(36).slice(2,9), input: key, expected_output: outputArray, created_at: now() };
    const idx = mem.findIndex(m => m.input === key);
    if (idx >= 0) mem[idx] = entry; else mem.push(entry);
    saveMemory(mem);
    return entry;
  }
  function removeMemoryById(id) {
    const mem = loadMemory().filter(m => m.id !== id);
    saveMemory(mem);
  }
  function updateMemoryById(id, obj) {
    const mem = loadMemory();
    const idx = mem.findIndex(m => m.id === id);
    if (idx >= 0) { mem[idx] = { ...mem[idx], ...obj }; saveMemory(mem); return mem[idx]; }
    return null;
  }
  function findMemoryExact(inputText) {
    const key = canonicalInput(inputText);
    return loadMemory().find(m => m.input === key) || null;
  }
  function findMemoryFuzzy(inputText) {
    const key = canonicalInput(inputText);
    return loadMemory().filter(m => m.input.includes(key) || key.includes(m.input)).slice(0,5);
  }

  // --- Theme handling ---
  const themeBtn = byId('btnThemeToggle');
  function applyTheme() {
    const theme = localStorage.getItem(THEME_KEY) || 'dark';
    document.body.classList.toggle('light', theme === 'light');
    if (themeBtn) themeBtn.textContent = (theme === 'light') ? 'Dark' : 'Light';
  }
  function toggleTheme() {
    const cur = localStorage.getItem(THEME_KEY) || 'dark';
    const next = cur === 'dark' ? 'light' : 'dark';
    localStorage.setItem(THEME_KEY, next);
    applyTheme();
  }

  // --- Offline / Online parsing ---
  const ONLINE_ENDPOINT = '/process-notam';
  const ONLINE_TIMEOUT = 2500; // ms

  async function callOnline(notamText) {
    try {
      const controller = new AbortController();
      const timer = setTimeout(() => controller.abort(), ONLINE_TIMEOUT);
      const res = await fetch(ONLINE_ENDPOINT, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ notam: notamText }),
        signal: controller.signal
      });
      clearTimeout(timer);
      if (!res.ok) throw new Error('bad response ' + res.status);
      return await res.json();
    } catch (e) {
      return null;
    }
  }

  function parseOffline(notamText) {
    if (window.OfflineNotamParser && typeof window.OfflineNotamParser.parse === 'function') {
      try {
        return window.OfflineNotamParser.parse(notamText);
      } catch (e) {
        return { success: false };
      }
    }
    return { success: false };
  }

  // try to parse text lines or JSON returned by model
  function extractSegmentsFromModelText(text) {
    if (!text) return [];
    text = String(text).trim();
    // If JSON, parse
    try {
      const parsed = JSON.parse(text);
      if (parsed && Array.isArray(parsed.segments)) return parsed.segments;
    } catch (e) {
      // not JSON
    }
    // fallback: split lines and return non-empty lines
    const lines = text.split(/\r?\n/).map(s => s.trim()).filter(Boolean);
    return lines.length ? lines : [];
  }

  // --- UI helpers ---
  const inputArea = byId('notamInput');
  const outputArea = byId('notamOutput');
  const parseOfflineBtn = byId('btnParseOffline');
  const saveMemoryBtn = byId('btnSaveMemory');

  function setOutput(text, extra = '') {
    if (!outputArea) return;
    outputArea.textContent = text + (extra ? '\n\n' + extra : '');
  }

  // Save-to-memory dialog: prompt user for expected output (comma-separated)
  function promptAndSaveMemory(rawNotam, suggested = []) {
    // suggested is an array — present as joined lines
    const suggestedText = suggested.length ? suggested.join('\n') : '';
    const promptText = 'Enter expected outputs (comma-separated) for this NOTAM.\n\nSuggested:\n' + suggestedText + '\n\nIf you cancel, nothing will be saved.';
    const user = prompt(promptText, suggested.join(', '));
    if (!user) { alert('Save cancelled'); return null; }
    const arr = user.split(',').map(s => s.trim()).filter(Boolean);
    addMemoryEntry(rawNotam, arr);
    updateMemoryBadge();
    alert('Saved to memory: ' + arr.length + ' item(s).');
    return arr;
  }

  // --- Parse flow orchestrator ---
  async function parseNotamFlow(forceOffline = false) {
    const raw = inputArea ? inputArea.value : '';
    if (!raw || !raw.trim()) { setOutput('[ERROR] empty input'); return; }

    // 1) check memory exact match
    const memExact = findMemoryExact(raw);
    if (memExact && Array.isArray(memExact.expected_output) && memExact.expected_output.length) {
      setOutput(memExact.expected_output.join('\n'), '(Recalled from memory)');
      return;
    }

    // 2) try online unless forced offline
    if (!forceOffline) {
      const online = await callOnline(raw);
      if (online && Array.isArray(online.segments) && online.segments.length) {
        setOutput(online.segments.join('\n'), '(Online parser)');
        // Ask user whether to save to memory (auto-suggest)
        if (confirm('Save online result to memory? (OK = save, Cancel = skip)')) {
          addMemoryEntry(raw, online.segments);
          updateMemoryBadge();
        }
        return;
      }
    }

    // 3) offline parser
    const offline = parseOffline(raw);
    if (offline && offline.success && Array.isArray(offline.segments) && offline.segments.length) {
      setOutput(offline.segments.join('\n'), '(Offline parser)');
      // Ask user to save offline result
      if (confirm('Save offline result to memory? (OK = save, Cancel = skip)')) {
        addMemoryEntry(raw, offline.segments);
        updateMemoryBadge();
      }
      return;
    }

    // 4) no parse result — allow user to enter expected output for memory
    setOutput('[Saved to memory for learning] Provide expected output using the dialog.', '');
    // Save placeholder and prompt user for expected output
    const suggested = [];
    addMemoryEntry(raw, null); // store placeholder
    updateMemoryBadge();
    promptAndSaveMemory(raw, suggested);
  }

  // --- Save button handler (opens prompt if needed) ---
  function onSaveToMemoryClicked() {
    const raw = inputArea ? inputArea.value : '';
    if (!raw || !raw.trim()) { alert('No NOTAM input to save.'); return; }
    // If outputArea has content, use it as suggestion
    const out = outputArea ? outputArea.textContent.trim() : '';
    const suggested = out ? out.split(/\r?\n/).map(s => s.trim()).filter(Boolean) : [];
    promptAndSaveMemory(raw, suggested);
  }

  // --- Admin panel (simple modal) ---
  function openMemoryAdmin() {
    // create modal if missing
    let modal = byId('memoryAdminModal');
    if (!modal) {
      modal = document.createElement('div');
      modal.id = 'memoryAdminModal';
      modal.style.position = 'fixed';
      modal.style.left = '50%';
      modal.style.top = '50%';
      modal.style.transform = 'translate(-50%,-50%)';
      modal.style.width = '760px';
      modal.style.maxWidth = '95%';
      modal.style.maxHeight = '80%';
      modal.style.overflow = 'auto';
      modal.style.background = 'var(--panel-night)';
      modal.style.color = 'var(--text-night)';
      modal.style.padding = '18px';
      modal.style.borderRadius = '12px';
      modal.style.boxShadow = '0 10px 30px rgba(0,0,0,0.6)';
      modal.style.zIndex = 100000;
      modal.innerHTML = `
        <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:12px;">
          <h3 style="margin:0">Memory Admin</h3>
          <div>
            <button id="closeMemAdmin" class="btn secondary-btn" style="margin-right:8px">Close</button>
            <button id="exportMem" class="btn primary-btn">Export JSON</button>
          </div>
        </div>
        <div id="memList"></div>
        <div style="margin-top:12px;text-align:right;">
          <button id="importMemBtn" class="btn secondary-btn">Import JSON</button>
        </div>
      `;
      document.body.appendChild(modal);
      byId('closeMemAdmin').addEventListener('click', () => modal.remove());
      byId('exportMem').addEventListener('click', () => {
        const data = JSON.stringify(loadMemory(), null, 2);
        const blob = new Blob([data], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url; a.download = 'memory.json'; a.click(); URL.revokeObjectURL(url);
      });
      byId('importMemBtn').addEventListener('click', () => {
        const txt = prompt('Paste memory JSON to import (will replace existing memory).');
        if (!txt) return;
        try {
          const parsed = JSON.parse(txt);
          if (!Array.isArray(parsed)) throw new Error('Expected JSON array');
          saveMemory(parsed);
          alert('Imported memory entries: ' + parsed.length);
          renderMemList();
        } catch (e) { alert('Import failed: ' + (e.message || e)); }
      });
    }

    function renderMemList() {
      const container = byId('memList');
      container.innerHTML = '';
      const mem = loadMemory();
      if (!mem.length) { container.innerHTML = '<div style="opacity:.7">No memory entries saved.</div>'; return; }
      mem.forEach(entry => {
        const el = document.createElement('div');
        el.style.border = '1px solid rgba(255,255,255,0.04)';
        el.style.padding = '10px';
        el.style.marginBottom = '8px';
        el.style.borderRadius = '8px';
        el.innerHTML = `
          <div style="display:flex;justify-content:space-between;align-items:center">
            <div style="font-size:13px;color:var(--muted-text)">${entry.created_at}</div>
            <div>
              <button data-id="${entry.id}" class="editMem btn secondary-btn">Edit</button>
              <button data-id="${entry.id}" class="delMem btn secondary-btn">Delete</button>
            </div>
          </div>
          <div style="margin-top:8px"><strong>Input:</strong> <div style="font-family:monospace;background:rgba(0,0,0,0.05);padding:8px;border-radius:6px;margin-top:6px">${entry.input}</div></div>
          <div style="margin-top:8px"><strong>Output:</strong> <div style="font-family:monospace;background:rgba(0,0,0,0.05);padding:8px;border-radius:6px;margin-top:6px">${(entry.expected_output||[]).join('\\n')}</div></div>
        `;
        container.appendChild(el);
      });

      // wire edit/delete
      document.querySelectorAll('.delMem').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const id = e.currentTarget.getAttribute('data-id');
          if (!confirm('Delete this memory entry?')) return;
          removeMemoryById(id);
          renderMemList();
          updateMemoryBadge();
        });
      });
      document.querySelectorAll('.editMem').forEach(btn => {
        btn.addEventListener('click', (e) => {
          const id = e.currentTarget.getAttribute('data-id');
          const mem = loadMemory().find(m => m.id === id);
          if (!mem) return alert('Entry not found');
          const newOut = prompt('Edit expected output (comma-separated):', (mem.expected_output || []).join(', '));
          if (!newOut && newOut !== '') return;
          const arr = newOut.split(',').map(s => s.trim()).filter(Boolean);
          updateMemoryById(id, { expected_output: arr });
          renderMemList();
        });
      });
    }

    renderMemList();
  }

  // --- Built-in mapping for old inline handlers ---
  // Expose functions the old HTML expects
  window.toggleMode = toggleTheme;
  window.processNOTAM = () => parseNotamFlow(false);
  window.aiExplain = () => parseNotamFlow(false);
  window.aiSimplify = () => parseNotamFlow(false);
  window.aiRisk = () => parseNotamFlow(false);

  // --- Attach event listeners on DOM ready ---
  function init() {
    applyTheme();
    updateMemoryBadge();

    // Attach buttons
    if (parseOfflineBtn) parseOfflineBtn.addEventListener('click', () => parseNotamFlow(true));
    if (saveMemoryBtn) saveMemoryBtn.addEventListener('click', onSaveToMemoryClicked);

    // Admin button
    const memAdmin = byId('memoryAdminBtn');
    if (memAdmin) memAdmin.addEventListener('click', openMemoryAdmin);

    // Keyboard shortcut: Ctrl+Enter to parse
    if (inputArea) {
      inputArea.addEventListener('keydown', (ev) => {
        if (ev.ctrlKey && ev.key === 'Enter') { ev.preventDefault(); parseNotamFlow(false); }
      });
    }

    // expose for debugging
    window.oss = {
      parseNow: parseNotamFlow,
      memoryList: loadMemory,
      addMemory: (i,o) => addMemoryEntry(i,o)
    };
  }

  if (document.readyState === 'loading') document.addEventListener('DOMContentLoaded', init); else init();
})();
